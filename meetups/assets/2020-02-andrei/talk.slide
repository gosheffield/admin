Go and gRPC
How and why

6 Feb 2020
Tags: go, grpc, microservices

Andrei Simionescu
Interview Engineer, Karat
andrei@simionescu.eu
https://simionescu.eu/
@smnscu

https://github.com/grpc-ecosystem/awesome-grpc
https://github.com/alecthomas/go_serialization_benchmarks

* What is it?

gRPC Remote Procedure Calls

- open source remote procedure call (RPC) system initially developed at Google in 2015
- it uses HTTP/2 for transport, Protocol Buffers as the interface description language
- provides features such as authentication, bidirectional streaming and flow control, blocking or nonblocking bindings, and cancellation and timeouts
- it generates cross-platform client and server bindings for many languages
- most common usage scenarios include connecting services in microservices style architecture and connect mobile devices, browser clients to backend services.


* Why?

* Performance

HTTP/2
- Binary framing and compression. The HTTP/2 protocol is compact and efficient in both sending and receiving.
- Multiplexing of multiple HTTP/2 calls over a single TCP connection. Multiplexing eliminates head-of-line blocking.

In practice, around an order of magnitude faster than REST over HTTP 1.x.

~100¬µs de/serialization, sub-1ms transport within the same cluster with TLS

* Interoperability

Automatically generated client and server code for all major programming languages and platforms

Thanks to the Protocol Buffers binary wire format and the efficient code generation for each platform, developers can build performant apps while still enjoying full cross-platform support.

Comprehensive RPC solution with excellent tooling and a consistent experience across multiple languages and platforms.

* Structured

Schema definitions with protobuf
- No "design dichotomy" ‚Äì what's the right end-point to use, what's the right HTTP verb to use, etc.

Well-defined services using a data definition language

Formalized set of errors ‚Äï more directly applicable to API use cases than the HTTP status codes

Backwards compatibility

Full duplex streaming

* More

Secure (but not by default)
- HTTP/2 + TLS
- Support for Client Certificate authentication

Extensive tooling
- HTTP REST interface via annotations
- Add common functionality to multiple service endpoints via the Interceptor API, e.g. health checks, authentication

Excellent community support
- Used by _many_ large projects and companies

Great for mobile and even web clients
- Easy on the battery
- `grpc/grpc-web` and `improbable-eng/grpc-web` (neither support streaming)

* Why not?

* Why not?

High adoption cost

Opaque without proper tooling
- How do I cURL this? üëÄ

Async?

Development and operational overhead

Serialization overhead
- FlatBuffers
- Cap'n Proto

* Alternatives

Meh
- REST (MessagePack?) => REST-ish
- GraphQL
- WebSocket

RPC
- Apache Thrift - poor streaming performance
- Apache Avro - dynamic
- RSocket - obscure

Messaging
- ZeroMQ
- RabbitMQ
- Apache Kafka
- NSQ
- NATS

* How do I turn it on?

* Install it

  brew install protobuf

  go get google.golang.org/grpc
  npm install grpc
  pip install grpcio
  gem install grpc
  pecl install grpc-beta

  $ protoc --version
  libprotoc 3.11.3

.link https://grpc.io/docs/tutorials/basic/go/

* Service definition

The first step is to define a gRPC _service_ and the method _request_ and _response_ types.

    syntax "proto3";

    package routeguide;

    service RouteGuide {
        // Simple RPC, the client sends a request and waits for the response to come back.
        rpc GetFeature(Point) returns (Feature) {}

        // Server-side streaming RPC where the client sends a request to the server and
        // gets a stream to read a sequence of messages back, until there are no more messages.
        rpc ListFeatures(Rectangle) returns (stream Feature) {}

        // Client-side streaming RPC where the clients writes a sequence of messages and
        // sends them to the server using a provided stream. Then, it waits for the server
        // to read them all and return its response.
        rpc RecordRoute(stream Point) returns (RouteSummary) {}

        // Boss fight.
        rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
    }

* Message definition

Our `.proto` file also contains protocol buffer message type definitions for all the request and response types used in our service methods.

    message Point {
        int32 latitude = 1;
        int32 longitude = 2;
    }

    // A latitude-longitude rectangle, represented as two diagonally opposite
    // points "lo" and "hi".
    message Rectangle {
        // One corner of the rectangle.
        Point lo = 1;

        // The other corner of the rectangle.
        Point hi = 2;
    }

* Generating client and server code

Next we need to generate the gRPC client and server interfaces from our .proto service definition. We do this using the protocol buffer compiler `protoc` with a special gRPC Go plugin.

    $ protoc -I routeguide/ routeguide/route_guide.proto --go_out=plugins=grpc:routeguide

This will generate:

- All the protocol buffer code to populate, serialize, and retrieve our request and response message types
- An interface type (or stub) for clients to call with the methods defined in the `RouteGuide` service.
- An interface type for servers to implement, also with the methods defined in the `RouteGuide` service.

* Creating the server

There are two parts to making our RouteGuide service do its job:

- Implementing the service interface generated from our service definition: doing the actual ‚Äúwork‚Äù of our service.
- Running a gRPC server to listen for requests from clients and dispatch them to the right service implementation.

    type routeGuideServer struct {
            ...
    }
    ...

    func (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) {
            ...
    }
    ...

    func (s *routeGuideServer) ListFeatures(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) error {
            ...
    }
    ...

* Simple RPC

`routeGuideServer` implements all our service methods. `GetFeature` simply gets a `Point` from the client and returns the corresponding feature information from its database in a `Feature`.

    func (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) {
        for _, feature := range s.savedFeatures {
            if proto.Equal(feature.Location, point) {
                return feature, nil
            }
        }
        // No feature was found, return an unnamed feature
        return &pb.Feature{"", point}, nil
    }

The method is passed a context object for the RPC and the client‚Äôs `Point` protocol buffer request. After populating the `Feature` with the appropriate information, we return it along with a `nil` error to tell gRPC that we‚Äôve finished dealing with the RPC and the data can be returned to the client.

* Server-side streaming RPC

Now, we need to send back multiple `Features` to the client.

    func (s *routeGuideServer) ListFeatures(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) error {
        for _, feature := range s.savedFeatures {
            if inRange(feature.Location, rect) {
                if err := stream.Send(feature); err != nil {
                    return err
                }
            }
        }
        return nil
    }

Instead of getting  simple request and response objects in our method parameters, this time we get a request object (the `Rectangle` in which our client wants to find `Features`) and a special object to write our responses to.

Finally, as in our simple RPC, we return a nil error to tell gRPC that we‚Äôve finished writing responses.

* Client-side streaming RPC

    func (s *routeGuideServer) RecordRoute(stream pb.RouteGuide_RecordRouteServer) error {
        var pointCount, featureCount, distance int32
        var lastPoint *pb.Point
        for {
            point, err := stream.Recv()
            if err == io.EOF {
                endTime := time.Now()
                return stream.SendAndClose(&pb.RouteSummary{/*...*/})
            }
            if err != nil {
                return err
            }
            pointCount++
            for _, feature := range s.savedFeatures {
                if proto.Equal(feature.Location, point) {
                    featureCount++
                }
            }
            if lastPoint != nil {
                distance += calcDistance(lastPoint, point)
            }
            lastPoint = point
        }
    }

: Now let‚Äôs look at something a little more complicated: the client-side streaming method RecordRoute, where we get a stream of Points from the client and return a single RouteSummary with information about their trip. As you can see, this time the method doesn‚Äôt have a request parameter at all. Instead, it gets a RouteGuide_RecordRouteServer stream, which the server can use to both read and write messages - it can receive client messages using its Recv() method and return its single response using its SendAndClose() method.

: In the method body we use the RouteGuide_RecordRouteServer‚Äôs Recv() method to repeatedly read in our client‚Äôs requests to a request object (in this case a Point) until there are no more messages: the server needs to check the error returned from Read() after each call. If this is nil, the stream is still good and it can continue reading; if it‚Äôs io.EOF the message stream has ended and the server can return its RouteSummary. If it has any other value, we return the error ‚Äúas is‚Äù so that it‚Äôll be translated to an RPC status by the gRPC layer.

* Bidirectional streaming RPC

    func (s *routeGuideServer) RouteChat(stream pb.RouteGuide_RouteChatServer) error {
        for {
            in, err := stream.Recv()
            if err == io.EOF {
                return nil
            }
            if err != nil {
                return err
            }
            key := serialize(in.Location)
                    ... // look for notes to be sent to client
            for _, note := range s.routeNotes[key] {
                if err := stream.Send(note); err != nil {
                    return err
                }
            }
        }
    }

The syntax for reading and writing here is very similar to our client-streaming method, except the server uses the stream‚Äôs `Send()` method rather than `SendAndClose()` because it‚Äôs writing multiple responses.


: This time we get a RouteGuide_RouteChatServer stream that, as in our client-side streaming example, can be used to read and write messages. However, this time we return values via our method‚Äôs stream while the client is still writing messages to their message stream.

: Although each side will always get the other‚Äôs messages in the order they were written, both the client and server can read and write in any order ‚Äî the streams operate completely independently.

* Starting the server

Once we‚Äôve implemented all our methods, we also need to start up a gRPC server so that clients can actually use our service.

    flag.Parse()
    lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port))
    if err != nil {
            log.Fatalf("failed to listen: %v", err)
    }
    grpcServer := grpc.NewServer()
    pb.RegisterRouteGuideServer(grpcServer, &routeGuideServer{})
    ... // determine whether to use TLS
    grpcServer.Serve(lis)

: To build and start a server, we:

: Specify the port we want to use to listen for client requests using `lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port))`.
: Create an instance of the gRPC server using `grpc.NewServer()`.
: Register our service implementation with the gRPC server.
: Call `Serve()` on the server with our port details to do a blocking wait until the process is killed or Stop() is called.

* Creating the client

    conn, err := grpc.Dial(*serverAddr)
    if err != nil {
        ...
    }
    defer conn.Close()

Once the gRPC _channel_ is set up, we need a client _stub_ to perform RPCs.

    client := pb.NewRouteGuideClient(conn)

Calling the simple RPC `GetFeature` is nearly as straightforward as calling a local method.

    feature, err := client.GetFeature(context.Background(), &pb.Point{409146138, -746188906})
    if err != nil {
            ...
    }

* Client-side streaming RPC

The client-side streaming method `RecordRoute` is similar to the server-side method, except that we only pass the method a context and get a `RouteGuide_RecordRouteClient` stream back, which we can use to both write _and_ read messages.

    stream, err := client.RecordRoute(context.Background())
    if err != nil {
        log.Fatalf("%v.RecordRoute(_) = _, %v", client, err)
    }
    for _, point := range points {
        if err := stream.Send(point); err != nil {
            if err == io.EOF {
                break
            }
            log.Fatalf("%v.Send(%v) = %v", stream, point, err)
        }
    }
    reply, err := stream.CloseAndRecv()

: The RouteGuide_RecordRouteClient has a Send() method that we can use to send requests to the server. Once we‚Äôve finished writing our client‚Äôs requests to the stream using Send(), we need to call CloseAndRecv() on the stream to let gRPC know that we‚Äôve finished writing and are expecting to receive a response. We get our RPC status from the err returned from CloseAndRecv(). If the status is nil, then the first return value from CloseAndRecv() will be a valid server response.

* Bidirectional streaming RPC

    stream, err := client.RouteChat(context.Background())
    waitc := make(chan struct{})
    go func() {
        for {
            in, err := stream.Recv()
            if err == io.EOF {
                // read done.
                close(waitc)
                return
            }
            if err != nil {
                log.Fatalf("Failed to receive a note : %v", err)
            }
            log.Printf("Got message %s at point(%d, %d)", in.Message, in.Location.Latitude, in.Location.Longitude)
        }
    }()
    for _, note := range notes {
        if err := stream.Send(note); err != nil {
            log.Fatalf("Failed to send a note: %v", err)
        }
    }
    stream.CloseSend()
    <-waitc

: Finally, let‚Äôs look at our bidirectional streaming RPC RouteChat(). As in the case of RecordRoute, we only pass the method a context object and get back a stream that we can use to both write and read messages. However, this time we return values via our method‚Äôs stream while the server is still writing messages to their message stream.

: The syntax for reading and writing here is very similar to our client-side streaming method, except we use the stream‚Äôs CloseSend() method once we‚Äôve finished our call. Although each side will always get the other‚Äôs messages in the order they were written, both the client and server can read and write in any order ‚Äî the streams operate completely independently.

* Nice to know

* Well known types

Package google.protobuf

    Any (message)  Api (message)  BoolValue (message)  BytesValue (message)
    DoubleValue (message)  Duration (message)  Empty (message)  Enum (message)
    EnumValue (message)  Field (message) Field.Cardinality (enum)
    Field.Kind (enum)  FieldMask (message)  FloatValue (message)  Int32Value (message)
    Int64Value (message) ListValue (message)  Method (message)  Mixin (message)
    NullValue (enum) Option (message)  SourceContext (message)
    StringValue (message) Struct (message)  Syntax (enum) Timestamp (message)
    Type (message)  UInt32Value (message)  UInt64Value (message)  Value (message)

\.proto

    import "google/protobuf/struct.proto"
    import "google/protobuf/timestamp.proto"

    message NamedStruct {
      string name = 1;
      google.protobuf.Struct definition = 2;
      google.protobuf.Timestamp last_modified = 3;
    }

* github.com/gogo/protobuf (!!)

- fast marshalling and unmarshalling
- more canonical Go structures
- goprotobuf compatibility
- less typing by optionally generating extra helper code
- peace of mind by optionally generating test and benchmark code
- other serialization formats

    $ go get github.com/gogo/protobuf/proto
    $ go get github.com/gogo/protobuf/jsonpb
    $ go get github.com/gogo/protobuf/protoc-gen-gogo
    $ go get github.com/gogo/protobuf/gogoproto

    $ protoc --gofast_out=plugins=grpc:. my.proto

* Please, make it stop

    protoc -I=. -I=$GOPATH/src \
    -I=$GOPATH/src/github.com/gogo/protobuf/protobuf \
    --{binary}_out=. myproto.proto

That's not so bad. Wait, you want to use the files from `google/protobuf`?

    protoc -I=. -I=$GOPATH/src -I=$GOPATH/src/github.com/gogo/protobuf/protobuf --{binary}_out=\
    Mgoogle/protobuf/any.proto=github.com/gogo/protobuf/types,\
    Mgoogle/protobuf/duration.proto=github.com/gogo/protobuf/types,\
    Mgoogle/protobuf/struct.proto=github.com/gogo/protobuf/types,\
    Mgoogle/protobuf/timestamp.proto=github.com/gogo/protobuf/types,\
    Mgoogle/protobuf/wrappers.proto=github.com/gogo/protobuf/types:. \
    myproto.proto

* Interceptor API and go-grpc-middleware

A native way to add common functionality to either servers or clients.

    import "github.com/grpc-ecosystem/go-grpc-middleware"

    myServer := grpc.NewServer(
        grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
            grpc_ctxtags.StreamServerInterceptor(),
            grpc_opentracing.StreamServerInterceptor(),
            grpc_prometheus.StreamServerInterceptor,
            grpc_zap.StreamServerInterceptor(zapLogger),
            grpc_auth.StreamServerInterceptor(myAuthFunction),
            grpc_recovery.StreamServerInterceptor(),
        )),
        grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
            grpc_ctxtags.UnaryServerInterceptor(),
            grpc_opentracing.UnaryServerInterceptor(),
            grpc_prometheus.UnaryServerInterceptor,
            grpc_zap.UnaryServerInterceptor(zapLogger),
            grpc_auth.UnaryServerInterceptor(myAuthFunction),
            grpc_recovery.UnaryServerInterceptor(),
        )),
    )

* For example

.image assets/tracing.jpg _ 900

* Does it speak REST though?

* github.com/grpc-ecosystem/grpc-gateway

.image assets/grpc-gateway.png

    --grpc-gateway_out=logtostderr=true,repeated_path_param_separator=ssv:.
    --swagger_out=logtostderr=true,repeated_path_param_separator=ssv:.

.link https://github.com/grpc-ecosystem/grpc-gateway/blob/master/examples/proto/examplepb/a_bit_of_everything.proto "Simple" example

* Show, don't tell

* https://github.com/uw-labs/bloomrpc

.image assets/bloomrpc.gif

* Questions?


* TODO

- load balancing
- mocks